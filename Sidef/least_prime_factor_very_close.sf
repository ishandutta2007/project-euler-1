


# A038110/A038111
func D(p) {
    primes(p-1).prod {|q|
        1 - 1/q
    } / p
}

func G(n, p) {

    if (p > n.isqrt) {
        return 1
    }

    2..n -> count { .lpf == p }
}

func f(n) {
    var sum = 0

    for(var p = 2; true; p.next_prime!) {

        var t = G(n, p)
        sum += t*p

        if (t == 1) {
            sum += primes_sum(p+1, n)
            break
        }
    }

    sum
}

func g(n) {
    sum(2..n, {|k|
        k.lpf
    })
}

#say 20.of(f)
#say 20.of(g)

say f(1000)
say g(1000)


__END__

say f(1000)
say g(1000)
#say (20.of { f(.prime) } »-« 20.of { g(.prime) })


__END__


#~ a(n) = Sum_{prime p} n(p)*p, where n(p) is the number of integers in [1,n] with smallest prime factor spf(.) = A020639(.) = p. This function is decreasing from n(2) = floor(n/2) to n(p) = 1 for p >= sqrt(n) or earlier, and n(p) = 0 for p > n. The density of numbers having p as smallest prime factor is D(p) = (prod_{primes q < p} 1-1/q)/p = A038110/A038111, and n(p) = D(p)*n rounded up most often, or down in a few cases. From the first term on where n(p) = 1, the remainder of the sum is just the sum of the primes. - M. F. Hasler, Dec 05 2018

#~ a(n) = Sum_{prime p} n(p)*p, where n(p) is the number of integers in [1,n] with smallest prime factor spf(.) = A020639(.) = p, decreasing from n(2) = floor(n/2) to n(p) = 1 for p >= sqrt(n), possibly earlier, and n(p) = 0 for p > n. One has n(p) ~ D(p)*n where D(p) = (prod_{primes q < p} 1-1/q)/p = A038110/A038111 is the density of numbers having p as smallest prime factor. - M. F. Hasler, Dec 05 201


func f(n) {

    sum(1..n, {|B|

        var t = B.primorial

        say [B, prod(0..n, {|k|
        #binomial(n,k)
            #
            #binomial(n,k).divisors.grep{.is_smooth(B)}.max

            var u = 1
            var N = binomial(n, k)
            var g = gcd(N, t)

            while (g > 1) {
                N.remove!(g)
                u *= g
                break if (N == 1)
                g = gcd(N, t)
            }

            #say u

           # say [n, k, u]
            u #% 1_000_000_993
        }).factor_exp]
    }) % 1_000_000_993
}

#say 20.of(f)
say f(18)




__END__
#!/usr/bin/perl

# Daniel "Trizen" Șuteu
# Date: 07 May 2015
# https://github.com/trizen

# The arithmetic coding algorithm.

# See also:
#   https://en.wikipedia.org/wiki/Arithmetic_coding#Arithmetic_coding_as_a_generalized_change_of_radix

use 5.010;
use strict;
use warnings;

use Math::AnyNum;

#use Math::AnyNum (try => 'GMP');
#use Math::AnyNum (try => 'GMP');

sub asciibet {
    map { chr } 0 .. 255;
}

sub cumulative_freq {
    my ($freq) = @_;

    my %cf;
    my $total = Math::AnyNum->new(0);
    foreach my $c (asciibet()) {
        if (exists $freq->{$c}) {
            $cf{$c} = $total;
            $total += $freq->{$c};
        }
    }

    return %cf;
}

sub arithmethic_coding {
    my ($str) = @_;
    my @chars = split(//, $str);

    # The frequency characters
    my %freq;
    $freq{$_}++ for @chars;

    # The cumulative frequency table
    my %cf = cumulative_freq(\%freq);

    # Limit and base
    my $base = scalar @chars;

    # Lower bound
    my $L = Math::AnyNum->new(0);

    # Product of all frequencies
    my $pf = Math::AnyNum->new(1);

    # Each term is multiplied by the product of the
    # frequencies of all previously occurring symbols
    foreach my $c (@chars) {
        #$L->bmuladd($base, $cf{$c} * $pf);
        #$L *= $base + $cf{$c} * $pf;
        #$L *= $base;
        #$L +=
        $L = $L * $base + $cf{$c} * $pf;
        $pf *= ($freq{$c});
    }

    # Upper bound
    my $U = $L + $pf;

    my $len = $L->length;
    $L = Math::AnyNum->new("$L / " . Math::AnyNum->new(10)->pow($len));
    $U = Math::AnyNum->new("$U / " . Math::AnyNum->new(10)->pow($len));

    my $big_two = Math::AnyNum->new(2);
    my $two_pow = Math::AnyNum->new(1);
    my $n       = Math::AnyNum->new(0);

    my $bin = '';
    while ($n < $L || $n >= $U) {
        my $m = Math::AnyNum->new(1)->div($two_pow *= ($big_two));

        if ($n + $m < $U) {
            $n += $m;
            $bin .= '1';
        }
        else {
            $bin .= '0';
        }
    }

    #~ say $L;
    #~ say $U;

    return ($bin, $len, \%freq);
}

sub arithmethic_decoding {
    my ($enc, $pow, $freq) = @_;

    my $two_pow = Math::AnyNum->new(1);
    my $big_two = Math::AnyNum->new(2);

    my $line = Math::AnyNum->new(0);

    my @bin = split(//, $enc);
    foreach my $i (0 .. $#bin) {
        $line += (Math::AnyNum->new($bin[$i])->div(($two_pow *= ($big_two))));
    }

    $enc = ($line *= (Math::AnyNum->new(10)->pow($pow)));

    my $base = Math::AnyNum->new(0);
    $base += $_ for values %{$freq};

    # Create the cumulative frequency table
    my %cf = cumulative_freq($freq);

    # Create the dictionary
    my %dict;
    while (my ($k, $v) = each %cf) {
        $dict{$v} = $k;
    }

    # Fill the gaps in the dictionary
    my $lchar;
    foreach my $i (0 .. $base - 1) {
        if (exists $dict{$i}) {
            $lchar = $dict{$i};
        }
        elsif (defined $lchar) {
            $dict{$i} = $lchar;
        }
    }
 (((-3)^(floor(((3*k + kronecker(k, 3)) - 1)/3) + 1) Γ(-(3*k + kronecker(k, 3))/3 + floor(((3*k + kronecker(k, 3)) - 1)/3) + 1))/Γ(-(3*k + kronecker(k, 3))/3)) = -k (mod k^2)
    # Decode the input number
    my $decoded = '';
    for (my $i = $base - 1 ; $i >= 0 ; $i--) {

        my $pow = $base**$i;
        my $div = ($enc->idiv($pow));

        my $c  = $dict{$div};
        my $fv = $freq->{$c};
        my $cv = $cf{$c};

        my $rem = ($enc - $pow * $cv)->idiv($fv);

        #~ say "$enc / $base^$i = $div ($c)";
        #~ say "($enc - $base^$i * $cv) / $fv = $rem\n";

        $enc = $rem;
        $decoded .= $c;
    }

    # Return the decoded output
    return $decoded;
}

#
## Run some tests
#
foreach my $str (
    qw(DABDDB DABDDBBDDBA ABBDDD ABRACADABRA CoMpReSSeD Sidef Trizen google TOBEORNOTTOBEORTOBEORNOT),
    'In a positional numeral system the radix, or base, is numerically equal to a number of different symbols '
    . 'used to express the number. For example, in the decimal system the number of symbols is 10, namely 0, 1, 2, '
    . '3, 4, 5, 6, 7, 8, and 9. The radix is used to express any finite integer in a presumed multiplier in polynomial '
    . 'form. For example, the number 457 is actually 4×102 + 5×101 + 7×100, where base 10 is presumed but not shown explicitly.'
  ) {
    my ($enc, $pow, $freq) = arithmethic_coding($str);
    my $dec = arithmethic_decoding($enc, $pow, $freq);

    say "Encoded:  $enc";
    say "Decoded:  $dec";

    if ($str ne $dec) {
        die "\tHowever that is incorrect!";
    }

    say "-" x 80;
}
